/**
 * C++ Interoperability Test for Rescue Cipher
 * 
 * This program reads test vectors generated by the JavaScript implementation
 * and verifies that the C++ implementation produces identical results.
 */

#include <rescue/rescue.hpp>
#include <nlohmann/json.hpp>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <vector>
#include <cstdint>

using json = nlohmann::json;
using namespace rescue;

/**
 * Convert hex string to byte vector (little-endian)
 */
std::vector<uint8_t> hex_to_bytes(const std::string& hex) {
    std::vector<uint8_t> bytes;
    for (size_t i = 0; i < hex.length(); i += 2) {
        uint8_t byte = static_cast<uint8_t>(std::stoul(hex.substr(i, 2), nullptr, 16));
        bytes.push_back(byte);
    }
    return bytes;
}

/**
 * Convert byte vector to hex string
 */
std::string bytes_to_hex(const std::vector<uint8_t>& bytes) {
    std::stringstream ss;
    for (auto b : bytes) {
        ss << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
    }
    return ss.str();
}

/**
 * Convert hex string (little-endian) to Fp
 */
Fp hex_to_fp(const std::string& hex) {
    std::vector<uint8_t> bytes = hex_to_bytes(hex);
    return Fp::from_bytes(std::span<const uint8_t>(bytes));
}

/**
 * Convert Fp to hex string (little-endian)
 */
std::string fp_to_hex(const Fp& val) {
    auto arr = val.to_bytes();
    std::vector<uint8_t> bytes(arr.begin(), arr.end());
    return bytes_to_hex(bytes);
}

/**
 * Test result structure
 */
struct TestResult {
    int id;
    bool encryption_match;
    bool decryption_match;
    std::vector<std::string> cpp_ciphertext;
    std::vector<std::string> cpp_decrypted;
    std::vector<std::string> js_plaintext;
    std::vector<std::string> js_ciphertext;
};

int main(int argc, char* argv[]) {
    std::string input_file = "test_vectors_js.json";
    std::string output_file = "test_vectors_cpp.json";
    
    if (argc > 1) {
        input_file = argv[1];
    }
    if (argc > 2) {
        output_file = argv[2];
    }
    
    // Read test vectors
    std::ifstream ifs(input_file);
    if (!ifs.is_open()) {
        std::cerr << "Error: Could not open " << input_file << std::endl;
        return 1;
    }
    
    json test_data;
    ifs >> test_data;
    ifs.close();
    
    std::cout << "Rescue Cipher C++ Interoperability Test\n";
    std::cout << "========================================\n";
    std::cout << "Input file: " << input_file << "\n";
    std::cout << "Number of test vectors: " << test_data["num_tests"] << "\n\n";
    
    std::vector<TestResult> results;
    int passed = 0;
    int failed = 0;
    
    for (const auto& test_vec : test_data["test_vectors"]) {
        int test_id = test_vec["id"];
        std::cout << "Test " << test_id << ": ";
        
        TestResult result;
        result.id = test_id;
        
        try {
            // Parse shared secret (32 bytes)
            std::vector<uint8_t> shared_secret = hex_to_bytes(test_vec["shared_secret"]);
            
            // Parse nonce (16 bytes)
            std::vector<uint8_t> nonce = hex_to_bytes(test_vec["nonce"]);
            
            // Parse plaintext
            std::vector<Fp> plaintext;
            for (const auto& pt_hex : test_vec["plaintext"]) {
                plaintext.push_back(hex_to_fp(pt_hex));
                result.js_plaintext.push_back(pt_hex);
            }
            
            // Parse expected ciphertext
            std::vector<Fp> expected_ciphertext;
            for (const auto& ct_hex : test_vec["ciphertext_bigints"]) {
                expected_ciphertext.push_back(hex_to_fp(ct_hex));
                result.js_ciphertext.push_back(ct_hex);
            }
            
            // Create cipher
            RescueCipher cipher(shared_secret);
            
            // Encrypt (using raw API which works with Fp directly)
            std::vector<Fp> cpp_ciphertext = cipher.encrypt_raw(plaintext, nonce);
            
            // Store C++ ciphertext
            for (const auto& ct : cpp_ciphertext) {
                result.cpp_ciphertext.push_back(fp_to_hex(ct));
            }
            
            // Decrypt the JS ciphertext using C++ (raw API)
            std::vector<Fp> cpp_decrypted = cipher.decrypt_raw(expected_ciphertext, nonce);
            
            // Store C++ decrypted
            for (const auto& pt : cpp_decrypted) {
                result.cpp_decrypted.push_back(fp_to_hex(pt));
            }
            
            // Compare encryption
            result.encryption_match = (cpp_ciphertext.size() == expected_ciphertext.size());
            if (result.encryption_match) {
                for (size_t i = 0; i < cpp_ciphertext.size(); i++) {
                    if (cpp_ciphertext[i] != expected_ciphertext[i]) {
                        result.encryption_match = false;
                        break;
                    }
                }
            }
            
            // Compare decryption
            result.decryption_match = (cpp_decrypted.size() == plaintext.size());
            if (result.decryption_match) {
                for (size_t i = 0; i < cpp_decrypted.size(); i++) {
                    if (cpp_decrypted[i] != plaintext[i]) {
                        result.decryption_match = false;
                        break;
                    }
                }
            }
            
            if (result.encryption_match && result.decryption_match) {
                std::cout << "PASSED (encrypt: ✓, decrypt: ✓)\n";
                passed++;
            } else {
                std::cout << "FAILED (encrypt: " << (result.encryption_match ? "✓" : "✗")
                          << ", decrypt: " << (result.decryption_match ? "✓" : "✗") << ")\n";
                failed++;
                
                // Print details on failure
                if (!result.encryption_match) {
                    std::cout << "  Encryption mismatch at test " << test_id << ":\n";
                    for (size_t i = 0; i < std::min(cpp_ciphertext.size(), expected_ciphertext.size()); i++) {
                        if (cpp_ciphertext[i] != expected_ciphertext[i]) {
                            std::cout << "    [" << i << "] C++: " << fp_to_hex(cpp_ciphertext[i]) << "\n";
                            std::cout << "    [" << i << "] JS:  " << result.js_ciphertext[i] << "\n";
                        }
                    }
                }
                if (!result.decryption_match) {
                    std::cout << "  Decryption mismatch at test " << test_id << ":\n";
                    for (size_t i = 0; i < std::min(cpp_decrypted.size(), plaintext.size()); i++) {
                        if (cpp_decrypted[i] != plaintext[i]) {
                            std::cout << "    [" << i << "] C++: " << fp_to_hex(cpp_decrypted[i]) << "\n";
                            std::cout << "    [" << i << "] JS:  " << result.js_plaintext[i] << "\n";
                        }
                    }
                }
            }
            
        } catch (const std::exception& e) {
            std::cout << "ERROR: " << e.what() << "\n";
            result.encryption_match = false;
            result.decryption_match = false;
            failed++;
        }
        
        results.push_back(result);
    }
    
    std::cout << "\n========================================\n";
    std::cout << "Results: " << passed << " passed, " << failed << " failed\n";
    
    // Write output JSON
    json output;
    output["description"] = "C++ Rescue Cipher Test Results";
    output["total_tests"] = results.size();
    output["passed"] = passed;
    output["failed"] = failed;
    
    json test_results = json::array();
    for (const auto& r : results) {
        json tr;
        tr["id"] = r.id;
        tr["encryption_match"] = r.encryption_match;
        tr["decryption_match"] = r.decryption_match;
        tr["cpp_ciphertext"] = r.cpp_ciphertext;
        tr["cpp_decrypted"] = r.cpp_decrypted;
        tr["js_plaintext"] = r.js_plaintext;
        tr["js_ciphertext"] = r.js_ciphertext;
        test_results.push_back(tr);
    }
    output["test_results"] = test_results;
    
    std::ofstream ofs(output_file);
    ofs << std::setw(2) << output << std::endl;
    ofs.close();
    
    std::cout << "Results written to " << output_file << "\n";
    
    return failed > 0 ? 1 : 0;
}
