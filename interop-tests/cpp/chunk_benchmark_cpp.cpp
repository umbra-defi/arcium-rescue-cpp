/**
 * Chunked Benchmark - C++
 * 
 * Reads and benchmarks a single chunk of test cases generated by JS.
 * Called by the orchestrator script for each iteration.
 * 
 * Usage: ./chunk_benchmark_cpp <input_file> <stats_output_file>
 * 
 * Exit codes:
 *   0 = Success, all tests passed
 *   1 = Mismatch detected (interop failure)
 *   2 = Error (file not found, parse error, etc.)
 */

#include <rescue/rescue.hpp>
#include <nlohmann/json.hpp>

#include <chrono>
#include <ctime>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

using json = nlohmann::json;
using namespace rescue;

/**
 * Get current timestamp string
 */
std::string timestamp() {
    auto now = std::chrono::system_clock::now();
    auto time_t = std::chrono::system_clock::to_time_t(now);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        now.time_since_epoch()) % 1000;
    
    std::stringstream ss;
    ss << std::put_time(std::localtime(&time_t), "%H:%M:%S");
    ss << '.' << std::setfill('0') << std::setw(3) << ms.count();
    return ss.str();
}

/**
 * Log with timestamp and prefix
 */
void log(const std::string& msg) {
    std::cout << "[" << timestamp() << "] [C++] " << msg << "\n" << std::flush;
}

/**
 * Convert hex string to byte vector
 */
std::vector<uint8_t> hex_to_bytes(const std::string& hex) {
    std::vector<uint8_t> bytes;
    bytes.reserve(hex.length() / 2);
    for (size_t i = 0; i < hex.length(); i += 2) {
        uint8_t byte = static_cast<uint8_t>(std::stoul(hex.substr(i, 2), nullptr, 16));
        bytes.push_back(byte);
    }
    return bytes;
}

/**
 * Convert hex string (little-endian) to Fp
 */
Fp hex_to_fp(const std::string& hex) {
    std::vector<uint8_t> bytes = hex_to_bytes(hex);
    return Fp::from_bytes(std::span<const uint8_t>(bytes));
}

/**
 * Convert Fp to hex string (little-endian)
 */
std::string fp_to_hex(const Fp& val) {
    auto arr = val.to_bytes();
    std::stringstream ss;
    for (auto b : arr) {
        ss << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(b);
    }
    return ss.str();
}

/**
 * Format number with commas
 */
std::string format_number(size_t n) {
    std::string s = std::to_string(n);
    int insert_pos = static_cast<int>(s.length()) - 3;
    while (insert_pos > 0) {
        s.insert(insert_pos, ",");
        insert_pos -= 3;
    }
    return s;
}

int main(int argc, char* argv[]) {
    using Clock = std::chrono::high_resolution_clock;
    using Duration = std::chrono::nanoseconds;
    
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <input_file> <stats_output_file>\n";
        return 2;
    }
    
    std::string input_file = argv[1];
    std::string stats_file = argv[2];
    
    // Open and read input file
    log("Loading chunk from " + input_file + "...");
    
    std::ifstream ifs(input_file);
    if (!ifs.is_open()) {
        log("ERROR: Could not open " + input_file);
        return 2;
    }
    
    json data;
    try {
        ifs >> data;
    } catch (const std::exception& e) {
        log("ERROR: Failed to parse JSON: " + std::string(e.what()));
        return 2;
    }
    ifs.close();
    
    int chunk_index = data["chunk_index"];
    size_t chunk_size = data["chunk_size"];
    int start_id = data["start_id"];
    int end_id = data["end_id"];
    size_t js_total_elements = data["total_elements"];
    
    log("Chunk " + std::to_string(chunk_index) + " (tests " + 
        format_number(start_id) + "-" + format_number(end_id - 1) + ")");
    log("  Chunk size: " + format_number(chunk_size));
    log("  JS elements: " + format_number(js_total_elements));
    
    const auto& test_vectors = data["test_vectors"];
    
    // Benchmark variables
    Duration total_encrypt_time{0};
    Duration total_decrypt_time{0};
    Duration total_cipher_init{0};
    size_t total_elements = 0;
    size_t passed = 0;
    size_t failed = 0;
    
    auto overall_start = Clock::now();
    
    log("Processing " + format_number(test_vectors.size()) + " test vectors...");
    
    size_t count = 0;
    for (const auto& tv : test_vectors) {
        int test_id = tv["id"];
        
        // Parse inputs
        std::vector<uint8_t> shared_secret = hex_to_bytes(tv["shared_secret"]);
        std::vector<uint8_t> nonce = hex_to_bytes(tv["nonce"]);
        
        // Parse plaintext
        std::vector<Fp> plaintext;
        plaintext.reserve(tv["plaintext"].size());
        for (const auto& pt_hex : tv["plaintext"]) {
            plaintext.push_back(hex_to_fp(pt_hex.get<std::string>()));
        }
        
        // Parse expected ciphertext
        std::vector<Fp> expected_ciphertext;
        expected_ciphertext.reserve(tv["ciphertext"].size());
        for (const auto& ct_hex : tv["ciphertext"]) {
            expected_ciphertext.push_back(hex_to_fp(ct_hex.get<std::string>()));
        }
        
        total_elements += plaintext.size();
        
        // Create cipher
        auto cipher_start = Clock::now();
        RescueCipher cipher(shared_secret);
        auto cipher_end = Clock::now();
        total_cipher_init += std::chrono::duration_cast<Duration>(cipher_end - cipher_start);
        
        // Benchmark encryption
        auto enc_start = Clock::now();
        std::vector<Fp> cpp_ciphertext = cipher.encrypt_raw(plaintext, nonce);
        auto enc_end = Clock::now();
        total_encrypt_time += std::chrono::duration_cast<Duration>(enc_end - enc_start);
        
        // Benchmark decryption  
        auto dec_start = Clock::now();
        std::vector<Fp> cpp_decrypted = cipher.decrypt_raw(expected_ciphertext, nonce);
        auto dec_end = Clock::now();
        total_decrypt_time += std::chrono::duration_cast<Duration>(dec_end - dec_start);
        
        // Verify encryption matches JS
        bool enc_match = (cpp_ciphertext.size() == expected_ciphertext.size());
        if (enc_match) {
            for (size_t i = 0; i < cpp_ciphertext.size(); i++) {
                if (cpp_ciphertext[i] != expected_ciphertext[i]) {
                    enc_match = false;
                    log("ERROR: Encryption mismatch at test " + std::to_string(test_id) + 
                        ", index " + std::to_string(i));
                    log("  C++: " + fp_to_hex(cpp_ciphertext[i]));
                    log("  JS:  " + tv["ciphertext"][i].get<std::string>());
                    return 1;
                }
            }
        } else {
            log("ERROR: Ciphertext size mismatch at test " + std::to_string(test_id));
            log("  C++: " + std::to_string(cpp_ciphertext.size()));
            log("  JS:  " + std::to_string(expected_ciphertext.size()));
            return 1;
        }
        
        // Verify decryption matches original
        bool dec_match = (cpp_decrypted.size() == plaintext.size());
        if (dec_match) {
            for (size_t i = 0; i < cpp_decrypted.size(); i++) {
                if (cpp_decrypted[i] != plaintext[i]) {
                    dec_match = false;
                    log("ERROR: Decryption mismatch at test " + std::to_string(test_id) +
                        ", index " + std::to_string(i));
                    log("  C++: " + fp_to_hex(cpp_decrypted[i]));
                    log("  Expected: " + tv["plaintext"][i].get<std::string>());
                    return 1;
                }
            }
        } else {
            log("ERROR: Decrypted size mismatch at test " + std::to_string(test_id));
            return 1;
        }
        
        passed++;
        count++;
        
        // Progress every 100 tests
        if (count % 100 == 0) {
            double pct = (static_cast<double>(count) / chunk_size) * 100.0;
            std::cout << "\r[" << timestamp() << "] [C++]   Progress: " 
                      << count << "/" << chunk_size 
                      << " (" << std::fixed << std::setprecision(0) << pct << "%)" << std::flush;
        }
    }
    std::cout << "\n"; // newline after progress
    
    auto overall_end = Clock::now();
    auto overall_time = std::chrono::duration_cast<std::chrono::milliseconds>(overall_end - overall_start);
    
    // Calculate statistics
    double avg_enc_us = total_encrypt_time.count() / static_cast<double>(chunk_size) / 1000.0;
    double avg_dec_us = total_decrypt_time.count() / static_cast<double>(chunk_size) / 1000.0;
    double enc_throughput = total_elements / (total_encrypt_time.count() / 1e9);
    double dec_throughput = total_elements / (total_decrypt_time.count() / 1e9);
    
    log("Chunk " + std::to_string(chunk_index) + " complete:");
    log("  Total time: " + std::to_string(overall_time.count()) + "ms");
    log("  Elements: " + format_number(total_elements));
    log("  Cipher init: " + std::to_string(total_cipher_init.count() / 1000000) + "ms");
    
    std::stringstream ss;
    ss << std::fixed << std::setprecision(1);
    ss << "  Encrypt: " << (total_encrypt_time.count() / 1e6) << "ms (avg: " << avg_enc_us << "μs/test)";
    log(ss.str());
    
    ss.str("");
    ss << "  Decrypt: " << (total_decrypt_time.count() / 1e6) << "ms (avg: " << avg_dec_us << "μs/test)";
    log(ss.str());
    
    ss.str("");
    ss << std::fixed << std::setprecision(0);
    ss << "  Throughput: " << enc_throughput << " enc/s, " << dec_throughput << " dec/s";
    log(ss.str());
    
    log("  All " + format_number(passed) + " tests PASSED");
    
    // Write stats
    json stats;
    stats["chunk_index"] = chunk_index;
    stats["tests"] = chunk_size;
    stats["elements"] = total_elements;
    stats["encrypt_time_ns"] = total_encrypt_time.count();
    stats["decrypt_time_ns"] = total_decrypt_time.count();
    stats["avg_encrypt_us"] = avg_enc_us;
    stats["avg_decrypt_us"] = avg_dec_us;
    stats["encrypt_throughput"] = enc_throughput;
    stats["decrypt_throughput"] = dec_throughput;
    stats["passed"] = passed;
    stats["failed"] = failed;
    
    std::ofstream ofs(stats_file);
    ofs << std::setw(2) << stats << std::endl;
    ofs.close();
    
    log("Stats written to " + stats_file);
    
    return 0;
}
